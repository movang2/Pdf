<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PDF to TTS - X·ª≠ l√Ω vƒÉn b·∫£n th√¥ng minh</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            text-align: center;
            padding: 20px;
            max-width: 900px;
            margin: 0 auto;
            background-color: #f4f4f9;
        }
        h1 { color: #333; }
        
        /* Khu v·ª±c ƒëi·ªÅu khi·ªÉn */
        .control-panel {
            background: #fff;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-bottom: 20px;
        }
        
        .btn-group { margin: 10px 0; }
        
        button {
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 14px;
            transition: background 0.3s;
        }
        button:hover { background-color: #45a049; }
        button:disabled { background-color: #cccccc; cursor: not-allowed; }
        button.secondary { background-color: #008CBA; }
        button.stop { background-color: #f44336; }

        /* Canvas v√† Text Output */
        #pdfCanvas {
            border: 1px solid #ccc;
            margin: 20px auto;
            max-width: 100%;
            height: auto;
            display: block;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        #textOutput {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #e0e0e0;
            min-height: 100px;
            max-height: 300px;
            overflow-y: auto;
            text-align: left;
            background: #fff;
            white-space: pre-wrap; /* Gi·ªØ ƒë·ªãnh d·∫°ng d√≤ng */
            font-size: 14px;
            line-height: 1.6;
        }
        #currentSentence {
            margin-top: 20px;
            padding: 15px;
            border-left: 5px solid #2196F3;
            background-color: #e3f2fd;
            min-height: 60px;
            font-weight: 500;
            color: #0d47a1;
            font-size: 1.1em;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #status {
            color: #666;
            margin-top: 10px;
            font-style: italic;
        }

        /* L·ªãch s·ª≠ */
        #historyList {
            margin-top: 30px;
            text-align: left;
            background: #fff;
            padding: 15px;
            border-radius: 8px;
        }
        .history-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .history-item:last-child { border-bottom: none; }
        .file-info { font-weight: 500; color: #333; cursor: pointer; }
        .file-info:hover { color: #2196F3; text-decoration: underline; }
        .delete-btn {
            color: #fff;
            background-color: #ff9800;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            border: none;
        }

        /* T√πy ch·ªçn x·ª≠ l√Ω */
        .options {
            margin: 15px 0;
            padding: 10px;
            background: #fffbe6;
            border: 1px solid #ffe58f;
            border-radius: 5px;
            display: inline-block;
        }
    </style>
</head>
<body>
    <h1>ƒê·ªçc PDF Th√¥ng Minh (T·ª± n·ªëi d√≤ng & X·ª≠ l√Ω c·ªôt)</h1>
    
    <div class="control-panel">
        <input type="file" id="pdfInput" accept=".pdf" />
        <br>
        <div class="options">
            <label>
                <input type="checkbox" id="smartProcess" checked> 
                <strong>B·∫≠t ch·∫ø ƒë·ªô gh√©p d√≤ng th√¥ng minh</strong> (D√πng cho s√°ch/b√°o c√≥ ng·∫Øt d√≤ng nhi·ªÅu)
            </label>
        </div>

        <div class="btn-group">
            <button class="stop" onclick="stopSpeech()">‚èπ D·ª´ng</button>
            <button class="secondary" onclick="pauseSpeech()">‚è∏ T·∫°m d·ª´ng</button>
            <button class="secondary" onclick="resumeSpeech()">‚ñ∂ Ti·∫øp t·ª•c</button>
        </div>

        <div class="btn-group">
            <button onclick="previousPage()">‚¨Ö Trang tr∆∞·ªõc</button>
            <input type="number" id="pageInput" min="1" style="width: 60px; padding: 8px; text-align: center;" placeholder="Trang" />
            <button onclick="goToPage()">ƒêi ƒë·∫øn</button>
            <button onclick="nextPage()">Trang sau ‚û°</button>
        </div>
        
        <input type="range" id="pageSlider" min="1" value="1" style="width: 100%; margin-top: 10px;" disabled />
        <div id="status">Vui l√≤ng ch·ªçn file PDF ƒë·ªÉ b·∫Øt ƒë·∫ßu</div>
    </div>

    <div id="currentSentence">C√¢u ƒëang ƒë·ªçc s·∫Ω hi·ªÉn th·ªã ·ªü ƒë√¢y...</div>
    
    <canvas id="pdfCanvas"></canvas>
    
    <div id="textOutput">N·ªôi dung vƒÉn b·∫£n g·ªëc (ƒë√£ x·ª≠ l√Ω) s·∫Ω hi·ªán ·ªü ƒë√¢y...</div>

    <div id="historyList">
        <h3>üìö L·ªãch s·ª≠ ƒë·ªçc</h3>
        <div id="historyContent"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.9.359/pdf.min.js"></script>
    <script src="https://unpkg.com/tesseract.js@v5.0.0/dist/tesseract.min.js"></script>
    
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.9.359/pdf.worker.min.js';

        let pdfDoc = null;
        let currentPage = 1;
        let totalPages = 0;
        let isSpeaking = false;
        let isPaused = false;
        let currentUtterance = null;
        let currentFileName = "";
        
        // L·ªãch s·ª≠ ƒë·ªçc
        let fileHistory = JSON.parse(localStorage.getItem('pdfReadingHistory')) || [];

        // --- S·ª± ki·ªán ---
        document.getElementById('pdfInput').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file && file.type === "application/pdf") {
                const fileReader = new FileReader();
                fileReader.onload = function() {
                    const typedArray = new Uint8Array(this.result);
                    loadPDF(typedArray, file.name);
                };
                fileReader.readAsArrayBuffer(file);
            }
        });

        document.getElementById('pageSlider').addEventListener('change', (e) => {
            const pageNum = parseInt(e.target.value);
            stopSpeech();
            renderPage(pageNum);
        });

        // --- Core Functions ---

        async function loadPDF(data, fileName) {
            try {
                stopSpeech();
                currentFileName = fileName;
                pdfDoc = await pdfjsLib.getDocument({ data }).promise;
                totalPages = pdfDoc.numPages;

                document.getElementById('pageInput').max = totalPages;
                document.getElementById('pageSlider').max = totalPages;
                document.getElementById('pageSlider').disabled = false;

                // Kh√¥i ph·ª•c l·ªãch s·ª≠
                const historyItem = fileHistory.find(item => item.name === fileName);
                if (historyItem) {
                    currentPage = historyItem.page;
                    if (historyItem.total !== totalPages) historyItem.total = totalPages;
                    document.getElementById('status').innerText = `ƒê√£ kh√¥i ph·ª•c: Trang ${currentPage}`;
                } else {
                    currentPage = 1;
                    saveProgressToHistory(fileName, 1, totalPages);
                }

                renderPage(currentPage);
                updateHistoryList();
            } catch (error) {
                console.error("L·ªói t·∫£i PDF:", error);
                alert("L·ªói t·∫£i file PDF.");
            }
        }

        async function renderPage(pageNum) {
            if (!pdfDoc) return;
            if (pageNum < 1) pageNum = 1;
            if (pageNum > totalPages) pageNum = totalPages;
            currentPage = pageNum;
            
            document.getElementById('pageInput').value = currentPage;
            document.getElementById('pageSlider').value = currentPage;
            document.getElementById('status').innerText = `ƒêang x·ª≠ l√Ω trang ${currentPage}/${totalPages}...`;

            saveProgressToHistory(currentFileName, currentPage, totalPages);
            updateHistoryList();

            const page = await pdfDoc.getPage(currentPage);
            // TƒÉng scale l√™n 2.0 ƒë·ªÉ OCR ch√≠nh x√°c h∆°n v·ªõi ch·ªØ nh·ªè
            const scale = 2.0; 
            const viewport = page.getViewport({ scale });
            const canvas = document.getElementById('pdfCanvas');
            const context = canvas.getContext('2d');
            canvas.height = viewport.height;
            canvas.width = viewport.width;

            // Render PDF th√†nh h√¨nh ·∫£nh
            await page.render({ canvasContext: context, viewport: viewport }).promise;

            // X·ª≠ l√Ω OCR v√† ƒê·ªçc
            processPageText(canvas);
        }

        async function processPageText(canvas) {
            document.getElementById('status').innerText = `ƒêang nh·∫≠n di·ªán ch·ªØ (OCR) trang ${currentPage}...`;
            
            try {
                const { data: { text } } = await Tesseract.recognize(
                    canvas,
                    'vie', // Ng√¥n ng·ªØ ti·∫øng Vi·ªát
                    { logger: m => console.log(m) }
                );

                // --- X·ª¨ L√ù VƒÇN B·∫¢N TH√îNG MINH ---
                let finalText = text;
                const isSmartMode = document.getElementById('smartProcess').checked;

                if (isSmartMode) {
                    finalText = smartCleanText(text);
                }
                // ---------------------------------

                document.getElementById('textOutput').innerText = finalText;
                document.getElementById('status').innerText = `ƒêang ƒë·ªçc trang ${currentPage}...`;
                speakText(finalText);

            } catch (err) {
                console.error(err);
                document.getElementById('status').innerText = "L·ªói nh·∫≠n di·ªán vƒÉn b·∫£n.";
            }
        }

        // --- H√ÄM X·ª¨ L√ù VƒÇN B·∫¢N ƒê·∫∂C BI·ªÜT ---
        function smartCleanText(rawText) {
            if (!rawText) return "";
            
            let text = rawText;

            // 1. Lo·∫°i b·ªè c√°c d√≤ng r√°c (ch·ªâ c√≥ s·ªë, ho·∫∑c k√Ω t·ª± l·∫° th∆∞·ªùng xu·∫•t hi·ªán ·ªü Header/Footer)
            // V√≠ d·ª•: "10 V·∫†N C√ÇU H·ªéI", "Trang 5", ""
            text = text.replace(/^(\d+|Trang \d+|.*source:.*)$/gim, ""); 

            // 2. N·ªëi c√°c t·ª´ b·ªã g·∫°ch ngang xu·ªëng d√≤ng (Hyphenation)
            // V√≠ d·ª•: "ph∆∞∆°ng- \nph√°p" -> "ph∆∞∆°ng ph√°p"
            text = text.replace(/-\s*\n/g, ""); 
            text = text.replace(/-\s/g, "");

            // 3. QUAN TR·ªåNG: N·ªëi d√≤ng b·ªã ng·∫Øt sai
            // Logic: N·∫øu d√≤ng k·∫øt th√∫c kh√¥ng ph·∫£i d·∫•u c√¢u (.!?:) th√¨ n·ªëi v·ªõi d√≤ng sau
            // Thay th·∫ø d·∫•u xu·ªëng d√≤ng (\n) b·∫±ng kho·∫£ng tr·∫Øng, TR·ª™ KHI n√≥ l√† d·∫•u ng·∫Øt ƒëo·∫°n (\n\n)
            
            // B∆∞·ªõc 3a: Chu·∫©n h√≥a xu·ªëng d√≤ng (ƒë√¥i khi OCR ra nhi·ªÅu \n th·ª´a)
            text = text.replace(/\n\s*\n/g, "||PARAGRAPH||"); // ƒê√°nh d·∫•u ƒëo·∫°n vƒÉn th·∫≠t
            
            // B∆∞·ªõc 3b: N·ªëi c√°c d√≤ng ƒë∆°n l·∫ª l·∫°i th√†nh c√¢u li·ªÅn m·∫°ch
            text = text.replace(/\n/g, " "); 
            
            // B∆∞·ªõc 3c: Kh√¥i ph·ª•c ƒëo·∫°n vƒÉn
            text = text.replace(/\|\|PARAGRAPH\|\|/g, "\n\n");

            // 4. S·ª≠a l·ªói OCR ph·ªï bi·∫øn ti·∫øng Vi·ªát
            text = text.replace(/\|/g, "I"); // Ch·ªØ l hay b·ªã nh·∫ßm th√†nh |
            text = text.replace(/\s+/g, " ").trim(); // X√≥a kho·∫£ng tr·∫Øng th·ª´a

            return text;
        }

        // --- Text-to-Speech ---

        function speakText(text) {
            if (!text || text.trim().length < 5) {
                 document.getElementById('currentSentence').innerText = "(Trang n√†y √≠t ch·ªØ ho·∫∑c ch·ªâ c√≥ h√¨nh ·∫£nh)";
                 return;
            }

            // T√°ch c√¢u d·ª±a tr√™n d·∫•u ch·∫•m, h·ªèi, c·∫£m th√°n V√Ä xu·ªëng d√≤ng
            // Th√™m (?<=[.!?]) ƒë·ªÉ gi·ªØ l·∫°i d·∫•u c√¢u khi split (n·∫øu tr√¨nh duy·ªát h·ªó tr·ª£ lookbehind)
            // Ho·∫∑c d√πng regex ƒë∆°n gi·∫£n:
            const sentences = text.match(/[^.!?\n]+[.!?\n]+/g) || [text];
            
            let index = 0;

            function speakNext() {
                if (!isSpeaking) return;
                if (index >= sentences.length) {
                    isSpeaking = false;
                    document.getElementById('currentSentence').innerText = "ƒê√£ ƒë·ªçc xong trang n√†y.";
                    nextPage(); // T·ª± ƒë·ªông sang trang sau
                    return;
                }

                const s = sentences[index].trim();
                if (s.length > 0) {
                    currentUtterance = new SpeechSynthesisUtterance(s);
                    currentUtterance.lang = 'vi-VN';
                    currentUtterance.rate = 1.0; 

                    document.getElementById('currentSentence').innerText = s;

                    currentUtterance.onend = () => {
                        index++;
                        speakNext();
                    };
                    
                    currentUtterance.onerror = (e) => {
                        console.warn("L·ªói ƒë·ªçc:", e);
                        index++;
                        speakNext();
                    };

                    window.speechSynthesis.speak(currentUtterance);
                } else {
                    index++;
                    speakNext();
                }
            }

            window.speechSynthesis.cancel();
            isSpeaking = true;
            isPaused = false;
            speakNext();
        }

        function stopSpeech() {
            window.speechSynthesis.cancel();
            isSpeaking = false;
            isPaused = false;
            document.getElementById('status').innerText = "ƒê√£ d·ª´ng.";
            document.getElementById('currentSentence').innerText = "...";
        }

        function pauseSpeech() {
            if (isSpeaking && !isPaused) {
                window.speechSynthesis.pause();
                isPaused = true;
            }
        }

        function resumeSpeech() {
            if (isSpeaking && isPaused) {
                window.speechSynthesis.resume();
                isPaused = false;
            }
        }

        // --- Navigation & History ---

        function previousPage() {
            if (currentPage > 1) {
                stopSpeech();
                renderPage(currentPage - 1);
            }
        }

        function nextPage() {
            if (currentPage < totalPages) {
                stopSpeech();
                renderPage(currentPage + 1);
            }
        }

        function goToPage() {
            const p = parseInt(document.getElementById('pageInput').value);
            if (p >= 1 && p <= totalPages) {
                stopSpeech();
                renderPage(p);
            }
        }

        function saveProgressToHistory(name, page, total) {
            if (!name) return;
            const idx = fileHistory.findIndex(i => i.name === name);
            if (idx !== -1) {
                fileHistory[idx].page = page;
                fileHistory[idx].total = total;
                const item = fileHistory.splice(idx, 1)[0];
                fileHistory.unshift(item);
            } else {
                fileHistory.unshift({ name, page, total });
            }
            if (fileHistory.length > 10) fileHistory.pop();
            localStorage.setItem('pdfReadingHistory', JSON.stringify(fileHistory));
        }

        function deleteFromHistory(index) {
            fileHistory.splice(index, 1);
            localStorage.setItem('pdfReadingHistory', JSON.stringify(fileHistory));
            updateHistoryList();
        }

        function updateHistoryList() {
            const container = document.getElementById('historyContent');
            container.innerHTML = '';
            fileHistory.forEach((item, index) => {
                const div = document.createElement('div');
                div.className = 'history-item';
                div.innerHTML = `
                    <span class="file-info" onclick="alert('H√£y ch·ªçn l·∫°i file ${item.name} ƒë·ªÉ ƒë·ªçc ti·∫øp t·ª´ trang ${item.page}')">
                        ${item.name} <small>(Trang ${item.page}/${item.total})</small>
                    </span>
                    <button class="delete-btn" onclick="deleteFromHistory(${index})">X√≥a</button>
                `;
                container.appendChild(div);
            });
        }

        updateHistoryList();
    </script>
</body>
</html>

